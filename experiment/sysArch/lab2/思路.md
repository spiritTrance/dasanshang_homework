基本：四路组相联+伪LRU+写回+写分配

只要写一下就dirty为1

写回：**写命中**时，修改cache的dirty位为1，如果为1，则先写数据到内存，然后覆盖

写分配：**写缺失**时，只写入 Cache，而不写入内存

代码实现：

读命中：直接从cacheline返回

读缺失：dirty为0，则直接读内存，内存**同时**返回数据给cache和cpu，如果dirty为1，要写请求，先写入内存，然后内存读入cache和cpu

具体逻辑看P18



LRU算法：在多路选择器有问题时候，选择哪路的block替换掉，所以有LRU

伪LRU算法：好说，就是个查找树，访问一次cache，就记录下路径，找的时候再找一下就行

**问题**：什么时候换？无论是读或者写，只要访问过一次就换一下，不管是缺失还是命中

**实现**：bit记录近期走过的方向，比如0的话是左子树访问过，右子树没有访问过

继续观察这颗树！如果是way0到way1，那么最高位是0，2，3则为1，然后。。。

具体实现怎么办呢？先放一下。。。





AXI burst（突发传输）：





trace调试