## 实验内容[¶](https://osdocs.cqu.ai/lab4/tasks/#_1)

本次实验涉及的是文件系统，通过分析了解ucore文件系统的总体架构设计，完善读写文件操作，从新实现基于文件系统的执行程序机制（即改写do_execve），从而可以完成执行存储在磁盘上的文件和实现文件读写等功能。为了实现实验四的目标，提供了2个基本练习，要求完成实验报告。

#### 练习1: 完成读文件操作的实现（需要编码）[¶](https://osdocs.cqu.ai/lab4/tasks/#1)

首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。

请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，鼓励给出详细设计方案

#### 练习2: 完成基于文件系统的执行程序机制的实现（需要编码）[¶](https://osdocs.cqu.ai/lab4/tasks/#2)

改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu -j 16。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。

请在实验报告中给出设计实现基于”UNIX的硬链接和软链接机制“的概要设方案，鼓励给出详细设计方案

## 实验要求[¶](https://osdocs.cqu.ai/lab4/tasks/#_2)

1. 完成以上两个练习，给出编译运行后输出结果的截图。并在实验报告中对所写代码调用的函数的作用加以说明。
2. 需提交可以在我们给定的Docker环境中直接使用make qemu编译并运行的文件夹的压缩包。



# 练习1

```c
        if((blkoff = offset % SFS_BLKSIZE)!= 0) {           // judge the offset whether could be mod by size
            if(nblks){                                      // judge the remain block num
            size = SFS_BLKSIZE - blkoff;                    // matching the size
            }else{
            size  = endpos - offset;
            }
            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0) {
                goto out;
            }
            if ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != 0) {
                goto out;
            }
            alen += size;
            if (nblks == 0) {
                goto out;
            }
            buf += size, blkno ++, nblks --;
        }

        size = SFS_BLKSIZE;
        while(nblks != 0){
            if((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0) {
                goto out;
            }
            if((ret = sfs_block_op(sfs, buf, ino, 1)) != 0) {
                goto out;
            }
            alen += size, buf += size, blkno ++, nblks --;
        }

        if((size = endpos % SFS_BLKSIZE) != 0) {
            if ((ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0) {
                goto out;
            }
            if ((ret = sfs_buf_op(sfs, buf, size, ino, 0)) != 0) {
                goto out;
            }
            alen += size;
        }
```

代码中使用的`ret = sfs_bmap_load_nolock(sfs, sin, blkno, &ino)) != 0`这一函数，其中`sfs_bmap_load_nolock`的作用是获取基础块所对应的block的编号`ino`,sin在磁盘上block的大小会被读出来进行确认，如果blkno恰好与该值相同，则block值会自增1。这个函数通过引用返回出来的ino会作为block的索引，用于`sfs_block_op`或`sfs_buf_op`进行文件的读写操作（根据具体情况，函数内部将被赋予不同的函数指针）。整段代码分为if-while-if的整体结构，原因在于第一块和最后一块不一定会对齐，调用`sfs_buf_op`函数进行部分内容的读取；中间的块是一定对齐的，将会以块为单位调用`sfs_block_op`进行数据的读取。

# 练习2

改写proc.c中的load_icode函数和其他相关函数:

```

```

[操作系统实验报告 lab8 - 代码天地 (codetd.com)](https://www.codetd.com/article/10940531)