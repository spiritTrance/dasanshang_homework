# 摘要

本文内容：数据管理和处理建议和系统，包括数据存储系统和框架的回顾，以及内存管理的重要技术，还有高校内存数据和处理需要考虑的关键因素。



# 引言

硬盘的访存延迟与大数据的爆炸式增长不相匹配，不能满足业务要求。因此，需要一个将数据始终保存在随机访问内存(RAM)中的内存系统/数据库。

内存取代磁盘会成为一个趋势：多核cpu和内存量的增大和带宽的提示使得存放数据库的重要部分成为可能，分布式环境可以聚合大量服务器节点的内存，以便于大规模应用程序的应用。

数据库系统的发展：原因是硬件进步，大量数据的可用性和收集数据的速度，新兴的应用程序的推动。

性能提高：减少硬盘依赖，增加内存，部署内存系统，等等。

## 内存数据管理和处理的研究

- 索引查找：基于哈希的索引，基于树的索引（T-Tree,CSS-Trees,bbn-Tree,D_Tree,BD_Tree,Fast,Bw-tree,ART）
- 数据布局：桉行，按列，多层存储（几个增量行/列存储和一个主列存储组成，定期合并），碎片清理
- 并行：数据级并行，共享内存扩展并行，无共享扩展并行
- 并发控制/事务管理：基于轻量级计数器的；基于时间戳控制的
- 查询处理：Coarse-grained stored procedures，动态编译（JIT），查询优化
- 容错：预写日志记录（Wwrite-ahead logging），消除IO瓶jin使用组提交和日志合并，最近研究使用命令日志记录，只记录操作）
- 数据移除：处理数据容量超出主存容量的问题：使用NVM，采取驱逐机制，将冷数据移动到磁盘上，内存中数据进行重新组织。



各节组织：第二节介绍内存中数据管理的背景只是，第3节是关系型数据库和NoSQL数据库，第四节是内存的数据处理系统，5：比较，6：讨论研究机会，7：总结

# 内存系统的核心技术

## 内存层次结构

内存层次结构是根据访问延迟和到CPU的逻辑距离定义的。一般来说，它由寄存器、高速缓存(通常包括L1高速缓存、L2高速缓存和L3高速缓存)、

寄存器——cache——主存和磁盘

## 内存层次结构利用率

### 寄存器感知优化

- 传统迭代器式查询处理机制——糟糕的代码和数据局部性

- HyPer使用低层虚拟机(LLVM)编译器框架动态地将查询转换为机器码，通过尽可能避免递归函数调用并尽可能长时间地将数据保存在寄存器中，实现了良好的代码和数据局域性

- SIMD在超标量处理器中可用，它利用宽寄存器(例如256位)的帮助实现数据级并行。SIMD可以显著提高性能，特别是对于矢量式计算，这在大数据分析工作中非常常见

### 缓存感知优化

缓存丢失原因：数据缓存丢失和分布式系统下的指令缓存丢失

优化缓存：重新组织数据布局，压缩，着色，各种缓存索引（如缓存敏感搜索树[81]、缓存敏感bv - tree[82]、快速架构敏感树[85]和自适应基树[87]），缓存敏感算法（突发排序）

需要考虑的因素：：cacheline长度，缓存大小和缓存替换策略

## 非统一内存访问（NUMA）

NUMA的使用原因：提高可以部署在服务器节点中的主内存带宽和总内存大小。NUMA允许将多个内存控制器集群到单个服务器节点，从而创建多个内存域。

研究方向有三类：

#### 数据分区

- 对数据进行分区，使对远程NUMA域的内存访问最小化

用于最小化不同数据与之间的数据传输

NUMA系统具有高内存带宽和多核的优势

#### OLTP Latency

- 管理NUMA对延迟敏感工作负载的影响

由于NUMA系统具有异构访问延迟，它们对OLTP事务提出了一个具有挑战性的问题，OLTP事务通常对延迟非常敏感。

使用“hardware islands”

#### Data Shuffling

- 有效的NUMA域间数据洗牌

## 事务内存Transactional memory

软件事务内存(STM)和硬件事务内存(HTM)（表2有比较要注意）

HTM只适合小型和短的事务，因为如下缺点：大小限制，缓存相联导致错误的冲突，中断事件被停止

## NVRAM

新兴的非易失性存储器提出了大容量持久高速存储器的前景。NVM的例子包括具有块粒度可寻址性的NAND/NOR闪存和具有字节粒度可寻址性的非易失性随机访问内存。

缺点：但其块粒度的接口和昂贵的“擦除”操作使其只适合作为较低级的存储，如更换硬盘[30]、[32]或磁盘缓存[198]。

下面是具有字节寻址能力且性能与DRAM相当的NVRAM。

先进的NVRAM技术，如相变存储器[199]、自旋转移转矩磁性RAM (STTMRAM)[200]和忆阻器[201]，

NVRAM有其独特的特点，如有限的续航能力、写/读不对称、排序的不确定性和原子性

没有标准的机制/协议来保证NVRAM写的顺序和原子性

（中间有一节没读）

NVRAM给数据库带来的最受欢迎的好处是它的非易失性，这有利于更有效的日志记录和容错机制[127]，[128]，[129]，[130]。但是写原子性和确定性顺序应该通过精心设计的算法(如第6组)来保证和有效地实现。

# 内存数据存储系统

主要介绍一些内存数据库，包括关系数据库和NoSQL数据库，还有缓存系统

## 内存关系型数据库

- 例子：Oracle，IBMDB2，MySQL，PostgreSQL

### H-Store / VoltDB

- 是分布式的基于行的内存关系数据库，目的是高性能OLTP处理
- 假设：大多数事物模板事先已知，减少运行时事务解析的开销。

- H-Store:

  - 事务处理：顺序执行事物，设计了skewaware分区模型，目的是尽量减少多分区事务的数量，减轻工作负载时时钟歪斜的影响。

    - Horticulture分区模型可以大幅减少多分区事物的数量，并发控制方案需要区分单分区事务和多分区事物。H-Store设计了两种低开销并发控制方案：轻量级锁定和投机并发控制。
      - 前者允许在没有活动的多分区事务时不使用锁执行单分区事务；
      - 后者可以在等待2PC完成(正好在多分区事务的最后一个片段被执行之后)的同时投机地继续执行排队事务

    - 基于分区和并发控制策略，使用马尔可夫模型进行优化：(1)在它将访问最多的分区的节点上执行事务;(2)只锁定事务访问的分区;(3)禁用非中止事务的撤销日志;(4)推测地将事务提交到它不再需要访问的分区。

  - 数据溢出：anti-cache使得数据库允许存储比内存大的数据，性能牺牲少。在元组级上把冷数据移动到磁盘。

  - 容错：混合策略：每个分区被复制到k个站点，定期提交数据库状态，命令日志通过记录命令保存持久性；内存驻留的撤销日志可以支持一些可中止事物的回滚。命令日志记录方案适合节点故障不频繁的短事务。

### Hekaton

为高并发OLTP设计的，利用无锁或无锁存数据结构。采用了编译一次执行多次的策略，先将SQL语句和存储过程编译为C代码，然后再将C代码转换为machine code。

事务被分为两个阶段：正常处理阶段和验证阶段。前者不会阻塞事务，后者会检查read set和phantoms，解决未完成的提交依赖关系，并强制执行日志记录。

使用B树进行索引，并用逻辑页面id (pid)代替指针，可根据映射表转换为物理地址。

### HyPer/ScyPer

OLTP和OLAP的混合高性能内存数据库，最大限度地利用了现代硬件特性

OLTP事务以无锁风格（lock-less style）按顺序执行，该风格首次在[222]中提出，并行性是通过对数据库进行逻辑分区并允许多个分区约束事务并行实现的。

OLAP查询是在基于硬件支持的影子页面的虚拟内存快照机制实现的一致性快照上进行的，这是一种高效的并发控制模型，维护开销低。

OLAP queries are conducted on a consistent
snapshot achieved by the virtual memory snapshot mecha-
nism based on hardware-supported shadow pages, which is
an efficient concurrency control model with low mainte-
nance overhead

用了一种动态的查询编译方案，即先将SQL查询编译成汇编代码[112]，然后使用LLVM提供的优化JIT编译器[167]直接执行汇编代码。有利于实现寄存器局部性。



HyPer的分布式版本，即ScyPer[149]，采用主从架构，其中主节点负责所有OLTP请求，还充当OLAP查询的入口点，而辅助节点仅用于执行OLAP查询。

- Hyper的快照机制：HyPer通过fork子进程(通过fork()系统调用)用它自己复制的虚拟内存空间，基于硬件，维护开销小。其用于OLAP查询和处理长时间运行的事务。
- Register-conscious编译：使用LLVM编译器框架（为SQL查询生成可移植的汇编代码，查询处理的复杂部分(例如，复杂的数据结构管理，排序)仍然是用预编译的c++编写的。）），HyPer JIT编译模型旨在通过将递归函数调用扩展到代码片段循环中来避免函数调用，从而实现更好的代码局部性和数据局部性
- ART索引：使用自适应基树，按字典序按位排序。ART通过自适应地使用不同的内节点大小，在相同的、相对较大的跨度下，实现了空间效率和时间效率。

### SAP HANA

集成OLTP和OLAP[41]，并统一结构化(即关系表)[74]、半结构化(即图)[241]和非结构化数据(即文本)处理。

特性：

- 同时支持面向行和面向列的关系数据存储，以便优化不同的查询工作负载。
- 提供多种查询语言接口
- 支持基于时间轴索引[242]的时态查询
- 提供了基于多版本并发控制的快照隔离，基于优化的两阶段提交协议(2PC)的事务语义[243]，以及通过记录和定期检查点进入GPFS文件系统的容错功能[148]。



## 内存NoSQL数据库（In-Memory NoSQL Databases）

NoSQL数据库提供了与关系数据库不同的数据存储和检索机制。NoSQL数据库中的数据通常结构为树、图或键-值，而不是表关系。

为了可用性和分区容限而妥协一致性。

### MemepiC

- epiC[23]的内存版本
- 不仅提供作为分布式键值存储的低延迟存储服务，而且集成了内存中的数据分析功能，支持在线分析
- 特点：
  - Less-system-call design
  - Integration of storage service and analytics operations：集成了数据分析满足在线数据分析的需求
  - User-space virtual memory management ：可配置的分页策略[138]，允许在总数据大小超过内存大小时自由地将数据移出到磁盘

### MongoDB

面向文档的NoSQL数据库，对文档的模式几乎没有限制。文档级提供原子性，索引和数据分析只能在单个集合中进行。不支持“跨集合”查询

- 存储功能
  - 利用内存映射文件来管理和与所有数据交互。
    - 如果所有数据都能装进内存中，它可以充当完全内存数据库。
    - 否则，它将依赖于虚拟内存管理器(VMM)， VMM将决定何时以及将哪个页面页入或页出。
- 数据分析功能
  - 支持aggregation和mapreduce数据分析操作

### RAMCloud

分布式内存键值存储，具有低延迟、高可用性和高内存利用率的特点。

采用日志结构的数据组织，具有两级清理策略，以结构化内存和磁盘上的数据。这将导致较高的内存利用率和单一的统一数据管理策略。

### Redis

键值存储，支持一堆数据结构，包括哈希，列表，集合，有序集合和高级功能如发布-订阅消息传输，持久化机制如快照和仅追加的日志记录，有利于数据恢复。Redis是单线程的。

因为使用朴素的malloc/free分配内存，不适合作为LRU缓存，会导致严重的内存碎片。

### 内存图形数据库

Bitsy[254]是一个可嵌入的内存图形数据库

- 使用多级双缓冲区/日志，提高写事务性能，方便日志清理;使用顺序锁进行无锁读，提高读性能
- 设计原则：No seek：所有更改附加到无序事务日志中，并依赖于重新组织过程来清除过时的顶点和边。No socket，NoSQL

Trinity：用于图分析的内存分布式图数据库和计算平台[46]，[263]，其图模型是基于内存中键值存储建立的

## 内存缓存系统

缓存在提高系统性能方面起着重要的作用，可以为应用程序提供两种优化:通过允许从内存访问数据来优化磁盘I/O，以及通过保留结果而不需要重新计算来优化CPU工作负载

按照设计目标不同：

- 通用型：Memcached，BigTable cache[248]
- 加速分析任务：PACMan[264]和GridGain[51]
- 支持特定框架：net的NCache[265]和用于Windows服务器的Velocity/AppFabric
- 支持严格事务语义的系统：TxCache
- 网络缓存，如HashCache[268]

### Memcached

轻量级的内存中键值对象缓存系统，具有严格的LRU驱逐，分布式版本是通过客户端库实现的。

有针对各种语言的不同版本的客户端库，提供两种主要协议，即文本协议和二进制协议，并支持UDP和TCP连接。

数据组织：大哈希表索引索引的键值对对象，键是一个文本字符串，值是一个不透明的字节块

并发性：使用libevent库实现异步请求处理。此外，Memcached是一个多线程程序，具有细粒度的pthread互斥锁机制

分布式版本：Twemcache

### MemC3

主要促进读密集型工作负载facilitates read-intensive work-
loads，可以实现高并发性。使用Cuckoo Hashing。使用锁分条技术来平衡锁的粒度，并使用乐观锁来实现多阅读器/单写入并发性

- Optimistic Concurrent Cuckoo Hashing

### TxCache

基于快照的事务性缓存，用于管理对事务性数据库查询的缓存结果，使用版本控制来保证一致性。保持了多版本的一致性。每当缓存的结果的相关记录被更新时，缓存的结果就会自动失效。

# 内存数据处理系统IN-MEMORY DATA PROCESSING SYSTEMS

内存处理系统有两种类型:

- 专注于批处理的数据分析系统：Spark [55]， Piccolo [59]， SINGA [280]， Pregel [281]， GraphLab [47]， Mammoth [56]， Phoenix [57]， GridGain[51]

- 实时数据处理系统(即流处理)：Storm [53]， Yahoo!S4 [52]， Spark Streaming [54]， MapReduce Online[282]

## In-Memory Big Data Analytics Systems内存大数据分析系统

### Main Memory MapReduce

为交互式分析而设计的，有TB级别的数据，这些数据可以保存在一个小节点集群的内存中，具有较高的平均故障时间，但不能保证弹性

在传统MapReduce上的优化：

- 输入/输出数据缓存到内存中的键值存储区中
- 指定一个分区器来控制键如何在reducer之间映射到分区，从而保证分区稳定性以实现局部性

### Piccolo

- 以数据为中心的编程框架，跨多个节点运行数据分析计算，支持数据位置规范和面向数据的积累
- 支持以下功能：
  - 用户定义的累积函数(例如max、summation)可以与每个表相关联
  - 允许用户自定义分区函数
  - 通过一个全局的用户辅助检查点/恢复机制来处理机器故障
  - 通过工作窃取来优化计算中的负载平衡work stealing

### SparkRDD

用于大数据分析的数据抽象，称为弹性分布式数据集

主要特点：

- 弹性持久化模型来提供将数据集持久化到内存、磁盘或两者兼具的灵活性
- 轻量级的容错机制(即，沿袭lineage)，不需要检查点。

数据模型：为只读分布式数据集提供了一个抽象。数据修改是通过粗粒度的RDD转换实现的，该转换对RDD中的所有数据项应用相同的操作，从而生成一个新的RDD

作业调度：作业被组织到DAG中，DAG捕获作业的依赖关系。RDD使用延迟物化，也就是说，一个RDD不会被计算，除非它在一个动作中被使用(例如count())。

## 内存实时处理系统In-Memory Real-Time Processing Systems

### Spark Streaming

基于Spark[55]开发的流处理容错系统

目标是容忍延迟数秒的应用程序

### Yahoo!S4

S4是是一个完全分散的分布式流处理引擎，设计上并没有提供数据容错功能

# 定性的比较QUALITATIVE COMPARISON

从数据模型、支持的工作负载、索引、并发控制、容错、内存溢出控制和表3中的查询处理策略等方面总结了本文中阐述的一些具有代表性的内存数据管理系统

内存数据管理系统也可以根据其存储和数据分析等功能分为三类，即存储系统、分析系统和具有这两种功能的成熟系统:

把表三翻译一下就行了吧

# RESEARCH OPPORTUNITIES

介绍了优化方面研究的挑战和机遇：

- 索引，包括时间效率和空间效率。内存数据库的索引不同于基于磁盘的数据库的索引，后者关注的是I/O效率，而不是内存和缓存利用率。

- 数据布局：缓存相关的设计(如柱状结构、缓存线对齐)和空间利用优化(如压缩、数据碎片整理)是内存数据组织的主要重点
- 并行：应该利用三个级别的并行性，这在第1节中有详细介绍。在现代体系结构中增加指令级并行(例如位级并行，SIMD)。

- 并发控制/事务管理：无锁或无锁并发控制机制在内存中数据管理中很有前途，但应该注意它的意外中止

- 查询处理：现代CPU的高计算能力和易于使用的编译器基础设施，如LLVM[167]，使高效的动态编译[112]成为可能，这可以显著提高查询处理性能。
  SIMD或多核增强处理可用于加速复杂的数据库操作，如连接和排序，NUMA体系结构将在未来发挥更大的作用。
- 容错：保证数据库的持久性；IO瓶颈。尽可能减少关键路径上的I/O成本，使其对正常操作几乎不可见。命令日志记录[131]可以减少需要记录的数据；硬件/操作系统辅助的方法很有前途，如NVRAM、内存映射文件
- 数据溢出：解决数据溢出问题的方法可以分为三类:用户空间(例如H-Store反缓存[133]，Hekaton Siberia[134])，内核空间(例如OS Swap, MongoDB内存映射文件[65])和混合(例如高效OS分页[136]和UVMM[138])。

# 总结

随着内存成为新的磁盘，内存中的数据管理和处理对于学术界和工业界来说变得越来越有趣。将数据存储层从磁盘转移到主存可能导致超过100 ?响应时间和吞吐量方面的理论改进。当数据访问变得更快时，在传统的基于磁盘的系统中无关紧要的开销来源可能会显著降低总体性能。这种转变促使人们重新思考传统系统的设计，尤其是数据库，在数据布局、索引、并行性、并发控制、查询处理、容错等方面。现代CPU利用和内存层次结构的优化在内存系统的设计中起着重要作用，而新的硬件技术，如HTM和RDMA，为解决软件解决方案所遇到的问题提供了很有前途的机会。

在本次调查中，我们重点关注内存数据管理和处理的设计原则，以及设计和实现高效、高性能内存系统的实用技术。我们回顾了内存层次结构和一些高级技术，如NUMA和事务内存，它们为内存中的数据管理和处理提供了基础。此外，我们还讨论了一些开拓性的内存内NewSQL和NoSQL数据库，包括缓存系统、批处理和在线/连续处理系统。我们详细介绍了一些有发展前景的设计技术，从中我们可以学到实用的、具体的系统设计原则。

这个调查提供了一个关于内存管理的重要技术的全面回顾和到目前为止相关工作的分析，希望这将成为进一步面向内存的系统研究的有用资源。